<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.2.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.2.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="有志 有识 有恒">
<meta property="og:type" content="website">
<meta property="og:title" content="小虎头 加油">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="小虎头 加油">
<meta property="og:description" content="有志 有识 有恒">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小虎头 加油">
<meta name="twitter:description" content="有志 有识 有恒">






  <link rel="canonical" href="http://yoursite.com/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>小虎头 加油</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小虎头 加油</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">老兵不死，之渐凋零</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>




<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/10/ovs-ofputil-flow-mod/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohutou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小虎头 加油">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/10/ovs-ofputil-flow-mod/" itemprop="url">
                  OpenvSwitch结构体ofputil_flow_mod详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-10 21:34:55" itemprop="dateCreated datePublished" datetime="2018-06-10T21:34:55+09:00">2018-06-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-19 18:33:26" itemprop="dateModified" datetime="2018-06-19T18:33:26+09:00">2018-06-19</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>ofputil_flow_mod是一个很重要的结构体，ovs在初始化时添加默认流表项以及使用ovs-ofctl操作ovs的流表项时都涉及到该结构体。</li>
<li>本文涉及的代码是截至到2018年6月1日，ovs主干树的代码。</li>
</ul>
<h1 id="struct-ofputil-flow-mod详解"><a href="#struct-ofputil-flow-mod详解" class="headerlink" title="struct ofputil_flow_mod详解"></a>struct ofputil_flow_mod详解</h1><h3 id="list-node"><a href="#list-node" class="headerlink" title="list_node"></a>list_node</h3><ul>
<li>类型 struct ovs_list  描述双向链表节点的结构体。与linux内核的实现基本一样，为了兼容MSVS，初始化部分有所不同。</li>
</ul>
<h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><ul>
<li><p>类型struct minimatch 采用稀疏编码的方式对struct match压缩。struct minimatch和sttuct match定义如下：</p>
<figure class="highlight c"><figcaption><span>include/openvswitch/match.h:40 </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">match</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flow</span> <span class="title">flow</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flow_wildcards</span> <span class="title">wc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tun_metadata_allocation</span> <span class="title">tun_md</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  <figure class="highlight c"><figcaption><span>include/openvswitch/match.h:249</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">minimatch</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">miniflow</span> *<span class="title">flow</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">minimask</span> *<span class="title">mask</span>;</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">miniflow</span> *<span class="title">flows</span>[2];</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tun_metadata_allocation</span> *<span class="title">tun_md</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  struct minimatch由两个struct miniflow和一个struct tun_metadata_allocation组成；它们与struct match中的flow, wc和tun_md一一对应。OVS在只对struct match中的flow和wc字段使用稀疏编码的方式压缩，tun_md保持不变。实际上，minimatch只保存了match结构中的flow和ws字段中的非零部分（单位是8个字节）。tun_md字段保存的数据都与隧道（GRE、Vxlan等）相关，这部分数据保持不变。</p>
</li>
<li>ovs-ofctl中从字符串转换为minimatch的处理流程（ofp-flow.c:1474  parse_ofp_str__）：<br> 流程说明以添加“dl_type=0x0800,dl_dst=11:22:33:44:55:66”规则为例<ul>
<li>1 初始化struct ofputil_flow_mod结构体。</li>
<li>2 定义局部变量match并初始化（ofp-flow.c:1564 struct match match = MATCH_CATCHALL_INITIALIZER;)</li>
<li>3 调用ofputil_parse_key_value将字符串拆解成键值对{key，value}，例如示例的字符串被拆解成[{“dl_type”: “0x0800”},{“dl_dst”:”11:22:33:44:55:66}]</li>
<li>4 根据key，将value添加到match对应的字段中。<ul>
<li>在ofp_parse_field中，调用mf_parse解析value。mf_parse函数主要是将value转换为对应的数据。例如将MAC地址字符串转换为struct eth_addr。mf_parse在解析数据时，会同时解析数据的掩码。</li>
<li>数据转换完成后，调用mf_set函数设置match中对应的字段。mf_set调用match_set_*函数操作match中的数据。例如，在设置match的dl_dst字段时，最后调用match_set_dl_dst或match_set_dl_dst_masked.</li>
</ul>
</li>
<li>5 返回步骤3，直到所有的字符串解析完。</li>
<li>6 调用minimatch_init将match转换为minimatch  </li>
</ul>
</li>
</ul>
<h3 id="priority"><a href="#priority" class="headerlink" title="priority"></a>priority</h3><ul>
<li>类型int</li>
<li><p>OpenFlow协议流表规则的优先级，数值越大优先级越高。实际使用中，网络报文会与多个规则匹配，例如如下两条规则：</p>
<ul>
<li>1。“dl_dst=11:22:33:44:55:66, actions=output:x”</li>
<li>2。“in_port=a, dl_dst=11:22:33:44:55:66, actions=output:y”</li>
</ul>
<p>从端口A发送的目标MAC地址为“11:22:33:44:55:66”数据报文，与上面的两条规则都匹配。如果这两条规则的优先级是一样的，则按其加入的先后顺序处理；否则，按优先级来处理。如果规则1的优先级高于2，则2永远都不会被匹配上。</p>
</li>
</ul>
<h3 id="cookie和cookie-mask"><a href="#cookie和cookie-mask" class="headerlink" title="cookie和cookie_mask"></a>cookie和cookie_mask</h3><ul>
<li>类型ovs_be64</li>
<li>Cookie，有时也用其复数形式 Cookies，指某些网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据（通常经过加密）。cookie字段的作用是身份识别或session跟踪，OpenFlow协议本身支持多个控制器，但只有一个主控制（master）工作，其他的控制器（slave）只有在主控制器失效后，slave控制器才工作。cookie的作用更多的是与session跟踪相关的，例如在某一时段临时添加了一些特殊的处理，删除时可以通过该字段将其全部删除。<br>  cookie字段和cookie_mask字段在添加规则时被忽略，在删除和修改规则时被使用。</li>
</ul>
<h3 id="new-cookie和modify-cookie"><a href="#new-cookie和modify-cookie" class="headerlink" title="new_cookie和modify_cookie"></a>new_cookie和modify_cookie</h3><ul>
<li>new_cookie的类型是ovs_be64， modify_cookie的类型是布尔型</li>
<li>用于修改或添加cookie。<ul>
<li>添加流表规则时，该字段的值不能是UINT64_MAX. 可自行定义该值。modify_cookie的值为true。</li>
<li>在修改流表规则（OFPFC_MODIFY and OFPFC_MODIFY_STRICT）时，包含以下两种情况：<ul>
<li>1。 如果一个或多个规则匹配，并且“modify_cookie”被设置为true，则cookies被替换为new_cookie，</li>
<li>2。如果没有匹配的规则，则按照添加规则的方式处理。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="table-id"><a href="#table-id" class="headerlink" title="table_id"></a>table_id</h3><ul>
<li>类型uint8_t</li>
<li>规则被添加的表ID。openflow从1.1版本开始支持多级流表。在ovs-ofctl的命令中如果带有table参数，如：<br>  ovs-ofctl add-flow internal “priority=10,table=2,dl_type=0x08000,dl_dst=11:22:33:44:55:66,actions=output:1”<br>  则通信协议号被设置为OFPUTIL_P_OF10_STD_TID，通信的消息仍然是struct ofp10_flow_mod。表的id号被封装到command字段中。<br>  格式如下:</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">15—————–8</th>
<th style="text-align:center">7—————0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">table_id</td>
<td style="text-align:center">command</td>
</tr>
</tbody>
</table>
<ul>
<li>相关代码：<ul>
<li>ofputil_tid_command ： ofp-flow.c:356</li>
<li>ofm-&gt;command = ofputil_tid_command(fm, protocol);    ofp-flow.c:436和456</li>
</ul>
</li>
</ul>
<h3 id="command"><a href="#command" class="headerlink" title="command"></a>command</h3><ul>
<li>类型uint16_t</li>
<li>操作flow的命令。目前支持的命令如下：<ul>
<li>OFPFC_ADD 添加<ul>
<li>OFPFC_MODIFY 修改所有匹配的流表</li>
<li>OFPFC_MODIFY_STRICT 修改严格匹配的流表</li>
<li>OFPFC_DELETE 删除所有匹配的流表</li>
<li>OFPFC_DELETE_STRICT  修改严格匹配的流表</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="idle-timeout和hard-timeout"><a href="#idle-timeout和hard-timeout" class="headerlink" title="idle_timeout和hard_timeout"></a>idle_timeout和hard_timeout</h3><ul>
<li>类型uint16_t</li>
<li>idle_timeout和hard_timeout指定规则的有效期，单位秒。其中，idle_timeout指定流表规则失效前在多少秒中内是处于idle状态的，即没有任何报文与其匹配。而hard_timeout则是指流表在多少秒后失效，不管这期间是否有报文与该规则匹配。默认值为0，即永久生效。</li>
</ul>
<h3 id="buffer-id"><a href="#buffer-id" class="headerlink" title="buffer_id"></a>buffer_id</h3><ul>
<li>类型uint32_t</li>
<li>buffer_id指明被cache的数据报的ID，该字段是datapath设置的。默认值UINT32_MAX。</li>
</ul>
<h3 id="out-port和out-group"><a href="#out-port和out-group" class="headerlink" title="out_port和out_group"></a>out_port和out_group</h3><ul>
<li>out_port的类型是ofp_port_t，out_group的类型为unit32_t</li>
<li>out_port和out_group被ovs-ofctl的replace-flow命令使用，默认值 OFPP_ANY 。</li>
</ul>
<h3 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h3><ul>
<li>类型enum ofputil_flow_mod_flags</li>
<li>ovs扩展的功能的标记。默认值为0</li>
<li>相关代码， ofp-flows.c: 1578-1590和ofp-flow.h:35-65</li>
</ul>
<h3 id="importance"><a href="#importance" class="headerlink" title="importance"></a>importance</h3><ul>
<li>类型uint16_t</li>
<li>openflow一个表默认支持UINT_MAX个项，当添加表项时，如果此时没有剩余的存储空间则选择牺牲者。该值越高，被作为牺牲者的概率越大。默认值为0。</li>
<li>相关代码：<ul>
<li>rule_eviction_priority : ofproto.c:8493    </li>
</ul>
</li>
</ul>
<h3 id="ofpacts和ofpacts-len"><a href="#ofpacts和ofpacts-len" class="headerlink" title="ofpacts和ofpacts_len"></a>ofpacts和ofpacts_len</h3><ul>
<li>ofpacts的类型为struct ofpact *； ofpacts_len的类型为size_t</li>
<li><p>ofpacks封装openflow的action。在ovs_ofctl中解析转换的流程如下（ofp-actions.c:8741 ofpacts_parse__）：</p>
<ul>
<li>1。 调用ofputil_parse_key_value将字符串拆解成键值对{key，value}。例如“output:x”的key为“output”，值为x。</li>
<li>2。 调用ofpact_type_from_name判断key定义的操作，如果是返回真，则调用ofpact_parse在ofpacts设置action及其值。</li>
<li>3。ofpack_parse(ofp-actions.c:8709)中通过定义宏OFPACT和在ofp-actions.h中定义的宏OFPACTS调用相关函数设置action。例如被添加的操作是output，这里就调用parse_OUTPUT函数。</li>
<li><p>4。parse_OUTPUT函数中，首先判断output的操作中是否有“port”和“max_len”字符串，如果有，则调用ofpact_put_OUTPUT_TRUNC处理（NXAST_OUTPUT_TRUNC是ovs扩展的操作）；否则，调用ofputil_port_from_string将用字符串表示的端口号转换为ofp_port_t。下面看一下por_map参数是怎么得到的。</p>
<ul>
<li>在ofctl_flow_mod调用parse_ofp_flow_mod_str将字符串表示的flow转换为struct minimatch前，首先调用ports_to_accept函数来获得虚拟交换机所有的端口的描述信息，是否获得获取该信息是通过全局变量use_names（默认值-1）来控制的，use_names的值是通过ovs-ofctl工具的参数–names和–no-names改变的。如果use_names不为零，则调用get_port_map从ovs-vswitchd获得端口的描述信息。</li>
<li>get_port_map与ovs-vswitchd建立通信连接后，调用port_iterator_fetch_features函数读取当前虚拟交换机所有的端口信息。</li>
<li>port_iterator_fetch_features函数调用ofpraw_alloc生成类型为OFPTYPE_FEATURES_REQUEST的请求。注意调用参数是OFPRAW_OFPT_FEATURES_REQUEST，raw_info_get函数将其转换为OFPTYPE_FEATURES_REQUEST。</li>
<li>ovs-vswitchd收到请求后，调用handle_features_request将struct bridge结构体中的ofproto字段中的端口信息发送给请求者（ofproto.c:3309）。</li>
</ul>
</li>
<li><p>5。调用ofpact_put_OUTPUT（ofp-actions.h:1168）在ofpacts分配空间存储struct ofpact_output类型的数据。OFPP_CONTROLLER是指openflow的控制器，即将数据发送给openflow控制器。在我们的场景下，ovs不会设置外部的openflow控制器。所以ofpact_output的max_len字段为0.</p>
</li>
</ul>
</li>
<li>相关代码<ul>
<li>ofp-port.c:149</li>
<li>ofp-actions.c:8709</li>
<li>ofp-actions.h:1168</li>
<li>ofproto.c:3309</li>
</ul>
</li>
</ul>
<h3 id="ofpacts-tlv-bitmap"><a href="#ofpacts-tlv-bitmap" class="headerlink" title="ofpacts_tlv_bitmap"></a>ofpacts_tlv_bitmap</h3><ul>
<li>类型uint64_t</li>
<li>与特定的操作相关，如NXAST_RAW_CT, NXAST_RAW_MULTIPATH, ONFACT_RAW13_COPY_FIELD等。</li>
<li>默认值为0.</li>
<li>相关代码：<ul>
<li>of-flow.c:316     fm-&gt;ofpacts_tlv_bitmap = 0;</li>
<li>ofp-actions.inc2(自动生成的文件，在编译根目录的lib目录下)</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/01/ovs-code-note-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohutou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小虎头 加油">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/01/ovs-code-note-1/" itemprop="url">
                  OpenvSwitch代码阅读笔记（1）-- Freezing Translation
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-01 21:00:10" itemprop="dateCreated datePublished" datetime="2018-06-01T21:00:10+09:00">2018-06-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-19 18:36:10" itemprop="dateModified" datetime="2018-06-19T18:36:10+09:00">2018-06-19</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近几个月的工作主要是对Open vSwitch的Windows Server版进行功能扩展。在阅读代码过程中，在ovs-vswitchd处理数据平面的请求时，遇到frozen_state字段，今天在阅读Openflow流表转换的代码时，看到关于冻结转换的注释（ofproto-dpif-xflate.c:273 - 378），特此翻译如下。</p>
<h1 id="冻结转换-（Freezing-Translation）"><a href="#冻结转换-（Freezing-Translation）" class="headerlink" title="冻结转换 （Freezing Translation）"></a>冻结转换 （Freezing Translation）</h1><p>在转换的过程中，会遇到需要暂停并设置一个检查点的情况，这样，转换操作可以在以后重新开始。设置checkpoint的过程被称为“freezing”，而重启该操作的过程被称为“thawing”。</p>
<p>freezing的使用场景：</p>
<ol>
<li><p>“Recirculation”, 转换操作发现在不执行以完成的转换的情况下，它没有足够的信息完成剩余的转换操作。在这种情况下，转换操作被冻结（freeze）并且相应的数据被赋予一个唯一的“recirculation ID”，该值被保存在用户空间的一个表中（参见ofproto-dpif-rid.h）。同时，添加一个OVS_ACTION_ATTR_RECIRC的动作，该动作的值是“recirculation ID”。当一个数据报触发这个动作后，数据平面使用该ID重新查表。如果，数据平面没有找到对应的记录，数据平面将请求控制平面处理。控制平面从“recirculation table”中查到ID，如果此时相关的信息已知，就重启转换操作。<br>原生的例子是MPLS。MPLS在Openflow中的实现，只有在最后一个MPLS标签后面的协议被剥离后，才能知道数据报封装的具体的协议。就是说，OVS无法跳过MPLS标签直接解析数据帧头。因此，在这种情况下，通过“recirculation”操作解析MPLS封装的数据帧。<br>（OVS同时使用OVS_ACTION_ATTR_RECIRC来实现输出到绑定网卡的哈希操作。OVS预先生成所有在数据平面上输出到绑定网卡上的流表，因此，将数据报发给用户空间做再一次转换这样复杂的流程就不需要了，即，绑定网卡不会按照上面提到的过程来处理。）</p>
</li>
<li><p>“Continuation”。A continuation是Openflow控制器干预数据报处理的一种机制。当转换过程中遇到一个带有“pause”标记的“controller”操作，转换就被暂停，被冻结的数据经过序列化后，发送给Openflow的控制器。控制器然后检查或修改被冻结的数据，并最终将数据发送给虚拟交换机，然后虚拟交换机解冻这些数据并继续转换操作。</p>
</li>
</ol>
<p>冻结转换的主要问题时保存状态，因此当转换被解冻时，操作能够继续进行而没有被破坏。尤其是，动作必须按照下面的顺序保存：</p>
<ul>
<li>如果冻结转换的原因是需要更多的信息，指明冻结原因的操作。</li>
<li>任何其他的在当前流表中等待执行的操作。</li>
<li>如果转换在NXAST_RESUMIT中被冻结，任何其他的操作都在resubmit操作的后面。resubmit操作可能是嵌套的，所以必须返回到控制平面处理。</li>
<li>Openflow 1.1+中定义的操作集合。</li>
</ul>
<p>动作或流表查询所依赖的状态，必须保存，例如：</p>
<ul>
<li>元数据字段（输入端口，寄存器，OF1.1+的元数据，… ）</li>
<li>NXAST_STACK_PUSH和NXAST_STACK_POP操作使用的栈信息</li>
<li>在控制平面栈的每个级别上，流表的表ID和cookie被转换，因为它们在执行OFPAT_CONTROLLER操作（包括其他的方式）时是可见的。</li>
</ul>
<p>通过这些字段，转换控制状态的保存。当一个冻结转换被识别时，转化过程如下：</p>
<ol>
<li>设置‘freezing’为true。</li>
<li>设置‘exit’为true，这样后续的操作就会知道上一个操作从转换过程中推出。</li>
<li>在‘frozen_actions’中添加OFPACT_UNROLL_XLATE动作，并且为了以后能够很方便的找到当前的操作，frozen_actions.header指向这个动作。这个动作中保存了当前的表ID和cookie，所以在后续的环回的转换中，它们能被恢复过来。</li>
<li>添加指示环回的动作，以及流表中其他后续的动作到’frozen_actions’中，这样，它们就能被执行当该流表重新被执行转换时。</li>
<li>返回。</li>
<li>指示环回的动作也许被嵌套在被重新提交的请求中，该请求还有没有执行的动作。所有这些都表明，当前离开和冻结了动作，并且在‘frozen_actions’中再次添加OFPACT_UNROLL_XLATE动作，以及没有被执行的动作。</li>
</ol>
<p>如果因为环回冻结转换，调用者生成一个环回ID，并且保存所有的当前操作的状态。对于所有的环回转换，调用者把它们传递新的转换去执行。这个过程中，产生了一组可以被直接转换的ofpacks，这时，它们的处理就没什么特殊之处了。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/20/ovs-classifier-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohutou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小虎头 加油">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/20/ovs-classifier-note/" itemprop="url">
                  OpenVSwitch流分类器笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-20 22:30:29" itemprop="dateCreated datePublished" datetime="2018-05-20T22:30:29+09:00">2018-05-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-05-21 00:48:44" itemprop="dateModified" datetime="2018-05-21T00:48:44+09:00">2018-05-21</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div class="note primary"><ol>
<li>本文主要是对openvswitch的lib/classifier.h文件中关于流分类器注释的翻译。</li>
<li>翻译中，意译的地方较多。如有错误，或不准确的地方，欢迎邮件（<a href="mailto:13581561959@163.com" target="_blank" rel="noopener">13581561959@163.com</a>）讨论，谢谢。</li>
</ol></div>
<h1 id="什么是流分类器"><a href="#什么是流分类器" class="headerlink" title="什么是流分类器"></a>什么是流分类器</h1><p>流分类器保存了任意数量的“规则”，这些规则由一组用于匹配字段或子字段的值和规则的优先级组成。<span style="color:red"><font size="+1">每一个openflow表被实例化为一个流分类器</font></span>。</p>
<p>流分类器主要的设计目标。首先，给定一组数据报的报头，尽可能快地查找到与之匹配的优先级最高的规则。接下来的一节主要阐述第二个目标。</p>
<h1 id="“Un-wildcarding”"><a href="#“Un-wildcarding”" class="headerlink" title="“Un-wildcarding”"></a>“Un-wildcarding”</h1><p>流分类器的一个主要目标是生成一个通配掩码，作为数据报查找的连带产物，其指明数据报头的哪些位对于分类结果是至关重要的。理论上，在掩码中被置1的位表明，如果在数据报中与之相对应的位被反转，则分类器的结果可能改变。对于掩码中为零的位，则改变数据包头中相对应的位不会改变分类器的结果。因此，被标记为通配的字段在分类中不发挥作用。</p>
<p>这样的通配掩码对于支持采用通配的方式处理某些字段或子字段的数据平面非常有用。例如，如果为一个TCP数据报查找flow时不需要关心TCP源或目地端口，交换机的控制平面在数据平面上插入一个匹配任意端口（tcp协议的port）的流，这样，数据平面就可以自己处理包含其他TCP原和目标端口的数据报，而不需要ovs-vswitchd来辅助处理。对于Open vSwitch一类的软件交换机而言，这是非常有帮助的，当然，对于基于ASIC的交换机而言，一样能获得很好的效果。</p>
<h1 id="通配掩码的属性"><a href="#通配掩码的属性" class="headerlink" title="通配掩码的属性"></a>通配掩码的属性</h1><ul>
<li>“False 1-bits”是可接受的。就是说，把统配符掩码位设置为1将不会导致一个数据报被错误地转发。当然，一个被全部置1的通配符掩码将生成正确的分类结果，只是产生不必要的低效率。</li>
<li>“False 0-bits”会导致问题，所以必须避免。在极端的情况下，所有的掩码位都被置为0时，分类器的输出结果只会在只有一个能匹配所有的数据报的流的时输出正确的结果。</li>
<li>“0-bits”是期望的，因为这样，数据平面可以跟自主地处理，不过度地依赖ovs-vswitchd处理数据流。因此，提高了效率。</li>
<li>目前，我们没有找到非常好的方式来产生包含最大数量的0-bits通配掩码。后面会有专门的章节描述我们使用的各种估计方法。</li>
<li>在一个给定的分类器中，使用通配查询将产生一组不交叉的结果。尤其是：<br>假如分类器C1包含任意的规则集合而分类器C2的规则集合是空的。现在，使用一组数据包头H在C1中查找，输出结果是一个最高优先级的规则R1和通配掩码M。从包头H和通配掩码M生成一个新的规则R2，然后将R2加入到C2中，并赋予一个固定的优先级。如果对于数据报头H所有可能的集合都做这样的处理，那么这个过程不会试图添加任何重叠的规则到C2中，就是说，使用在这个过程中产生的规则匹配数据报时，只有一个规则被匹配。</li>
</ul>
<p>在查询过程中，分类器开始将通配符掩码全部置为0，就是说，全匹配。随着查询的进行，每一步在通配符掩码中添加限制条件，即，将0-bits变成完全匹配的1-bits。这个过程被称为“去通配”。如果一个查询检查一个特定的字段，则该字段对应的位必须“去通配”。通常，“去通配”对于正确性是必须的，但是对于性能是不理想的。</p>
<h1 id="基础分类器设计"><a href="#基础分类器设计" class="headerlink" title="基础分类器设计"></a>基础分类器设计</h1><p>假设，在分类器中，所有的规则都有相同的样式。例如，假如他们都匹配以太网源和目的地址，并且通配所有其他的字段。那么，很明显，分类器的实现方式是基于以太网源和目的地址的哈希表。如果，一个新的分类规则采用其他的形式，就可以添加一个基于这些规则中的字段的哈希表。查询时，在两个表中分别查询flow。如果，都返回空，分类器就不包含相应的规则；如果其中一个返回结果，其就是需要的结果；如果在两个中都发现了匹配结果，则结果是两个中优先级高的。</p>
<p>以上说明了，flow分类器的工作方式。在一个“struct classifier”中，每种格式的“struct cls_rule”会被挂载到一个独立的“struct cls_subtable”中。分类器在每个“struct cls_subtable”中查询目标结果，并且返回结果中优先级做的一个。subtalbes中按照其表中的最高优先级的值降序排列。这样，在查询过程中，可以跳过那些优先级比已查询到的结果低的subtables。这样做可以节约查询时间，并避免“去通配”操作。</p>
<div class="note "><p>一个分类器可能包含很多除了优先级都一样的规则。在这种情况下，只用优先级最高的规则被直接存储在“struct cls_subtable”中，而其他的几乎一样的规则被存储在优先级最高的规则的链表中。</p></div>
<h1 id="阶段查询（通配优化）"><a href="#阶段查询（通配优化）" class="headerlink" title="阶段查询（通配优化）"></a>阶段查询（通配优化）</h1><p>子表查询在规定的范围内被执行，从元数据（registers，in_port等），然后L2帧头，L3，最后是L4的端口。任何时候，如果在当前的subtable中没有结果则，其他的subtable都可以被跳过。</p>
<p>阶段查询不会减少查询时间，并且可能增加，因为它把单个表的哈希查询变成多个表的哈希查询。在一些重要的场景下，它显著地减少了“去通配”的操作。</p>
<h1 id="前缀跟踪（通配优化）"><a href="#前缀跟踪（通配优化）" class="headerlink" title="前缀跟踪（通配优化）"></a>前缀跟踪（通配优化）</h1><p>分类器使用前缀树（“tries”）来跟踪已经使用过的地址。这样，对于一个给定的地址分类器可以跳过那些很长的掩码的表。这样，对于不需要主机路由的地，数据平面flow的“去通配”被减少了。但是，由于需要访问额外的数据，就增加了查询时间。</p>
<p>Trie查询和阶段查询时交叉进行的。所以，前缀树只被搜索一次当被配置的字段与查询相关时。前缀查询结果被保存，所以在每次分类器查询时，每个tire最多被查询一次。</p>
<p>目前的实现中，跟踪大量的规则在每个地址前缀。更为激进的跳表方式是可能的，通过维护表的链表，其前缀包含相同长度的前缀，或者维护几个独立的trie。</p>
<p>前缀跟踪通过OVSDB的“Flow_table”表的“filedspec”字段配置。“fieldspec”是一个字符串。“prefix”值是由被逗号分隔的字段名组成。</p>
<p>对于任何一个flow表，可以被前缀跟踪使用的字段的数量是有限制的。目前，该值为3。</p>
<h1 id="分区（查询时间和通配优化）"><a href="#分区（查询时间和通配优化）" class="headerlink" title="分区（查询时间和通配优化）"></a>分区（查询时间和通配优化）</h1><p>假如一个分类器通过“resubmit”被用于在一个流水线中处理多阶段查询，不同阶段的区分通过metadata（即，OpenFlow 1.1+中定义的“metadata”）实现。例如，metadata值为1指明是上行规则，metadata值为2指明匹配ACLs规则，而metadata值3指明匹配下行规则。这样，以metadata的值为基础，一个分类器被拆分成多个子分类器。</p>
<p>分类器有一个特别的优化方法来加速匹配在这个场景下:</p>
<ul>
<li>每一个与metadata匹配的cls_subtable获得一个tag，其从subtable的掩码中得到。因此，很有可能是这样，每一个subtable有一个唯一的tag。（重复的tag会导致性能损失但是不影响正确性）</li>
<li><p>对于每个被任何cls_rule匹配的metadata值， 分类器创建一个“struct cls_partition”通过metadata值被索引。cls_partition有一个“tags”字段，它的值是所有的包含任何匹配cld_partition的metadata值的cls_subtable的tag的位或。换而言之，struct cls_partition把具有相同的metadata值的子表聚合到一起。</p>
<p>这样，一个flow的查询可以从flow的metadata的分区开始，然后跳过任何的cls_sbutable，其tag不与分区的tag交叉。（flow也必须在任何不匹配metadata的cls_subtable中查询。这样的cls_subtable的tag被赋值为TAG_ALL，所以它可以匹配任意的tag）。</p>
</li>
</ul>
<p>分区节省了查询时间通过减少子表查询。subtable查询的减少也减少了“去通配”操作的数量。</p>
<h1 id="分类器版本控制"><a href="#分类器版本控制" class="headerlink" title="分类器版本控制"></a>分类器版本控制</h1><p>分类器采用了版本控制的方式解决同步的性能问题。分类器的查询总是在一个特定的分类器版本上完成，分类器的版本被定义为一个自然数。</p>
<p>当一个新的规则被加入到分类其中，其被设置为在一个特定的版本上可见。如果，在插入的过程中被使用的版本号大于任何被使用的查询版本号，新的规则被认为是不可见的。这意味着查询不能找到该规则，但是该规则在分类器中立即能被使用。</p>
<p>类似地，一个规则能被标记为删除在接下来的版本中。为了删除一个规则而不影响到正在进行的查询，该规则应该被标记为不可见在一个特殊的版本中。这样，当所有的查询使用后期的版本时，该规则就可以被从分类器中移除。</p>
<p>分类器能够保存重复的规则（具有相同的匹配标准和优先级）当至多其中一个在任何既定的搜索过程中可见。调用者负责分类器修改时维护不变性。</p>
<p>分类器支持版本控制主要是因为以下两个原因：</p>
<ol>
<li>基于版本控制式的修改使得执行任意序列的分类器更改就像一个原子事务，在此期间，分类器的中间版本对于任何的查询是不可见的。同时，当一个规则被添加到将来的版本中，或者被标记为在当前版本后删除，这样的操作是可逆的，而不影响当前的查询。</li>
<li>性能：在极端的情况下，添加（或删除）大量的规则的代价与分类器中存储的规则的数量成正比。然而，当多个规则被添加（或删除）在一个操作中，这种极端的情况下的代价能够被避免，只要对于任何新的规则只能在批量的添加完成后才可见。</li>
</ol>
<div class="note "><p>注意：classifier_replace函数立刻替换一个规则，因此在版本管理系统中，它是不安全的。对于不使用版本管理的用户来说，它依然是有用的。</p></div>
<h1 id="延迟发布"><a href="#延迟发布" class="headerlink" title="延迟发布"></a>延迟发布</h1><p>从分类器中移除大量的规则的代价是昂贵的，因为相关的数据结构被拆卸，在很多的情况下仅仅是被重新初始化。在最坏的情况下，当每个规则的匹配规则都不同，维护匹配模式的代价是O（N^2）,其中N是不同的规则的数量。为了降低这个代价，分类器支持“延迟模式”，在这种情况下，改变内部的数据结构为了在将来的版本中查询也许不会被全部处理。处理最终会在延迟模式被关闭时最终完成。</p>
<p>这个特性可以和版本管理一同工作，因此所有的为将来的版本所做的改变在延迟模式下完成。然后，在新的版本被查询可见前，延迟模式被关闭，这时所有的数据都已经可以被新的查询看到。</p>
<p>为了使用延迟发布，首先调用classifier_defer(). 然后，修改分类器通过添加（使用一个特定的将来的版本号调用classifier_insert()）然后删除（调用cls_rule_make_removable_after_version()）。最后调用cls_rule_make_removable_after_version()，然后，声明新的版本可以被使用。</p>
<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>分类器可以安全地被多个reader线程同时使用，同时被一个writer，或者多个writer互斥对分类器修改。</p>
<p>因为分类器的规则是被RCU保护的，规则的销毁在其被从分类器中移除后必须被RCU保护。同时，当版本被使用时，规则的删除必须是经典的RCU延迟的。在这种情况下，规则的销毁是加倍的RCU延迟，即，第二次调用ovsrcu_postpone()函数销毁规则是在第一次RCU移除规则的回掉函数中被调用的。</p>
<p>那些查询中从来都不可见的规则与已经提及的规则的处理方式不同。这样的规则可以被马上移除，但是它们的销毁必须是RCU延迟的，因为规则的可见属性也许会被检查在规则被移除时。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/14/umdh-memory-leak/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohutou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小虎头 加油">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/14/umdh-memory-leak/" itemprop="url">
                  windows平台使用UMDH工具检测内存泄漏
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-14 21:20:30" itemprop="dateCreated datePublished" datetime="2018-05-14T21:20:30+09:00">2018-05-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-05-15 02:10:15" itemprop="dateModified" datetime="2018-05-15T02:10:15+09:00">2018-05-15</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <div class="note primary"><p>原创，欢迎转载，请注明出处</p></div>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在Windows平台上扩展ovs-vswitchd的功能时，遇到了内存泄漏的问题。查阅windbg的文档，使用UMDH工具解决。特此记录一下。<br><div class="note "><p>本文使用的工具随EWDK_rs3_release_16299_170928-1534开发套件发行，VS是否带有该工具请自行查阅。本文提及的工具在EWDK的安装目录的“Program Files\Windows Kits\10\Debuggers\x64\”文件夹中。本文的操作都是在控制台下执行的。默认系统的PATH变量中不包含这些命令所在的目录，请自行添加或执行命令时输入全路径。</p></div></p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h2 id="创建用户空间程序栈跟踪数据库（Create-user-mode-stack-trace-database）"><a href="#创建用户空间程序栈跟踪数据库（Create-user-mode-stack-trace-database）" class="headerlink" title="创建用户空间程序栈跟踪数据库（Create user mode stack trace database）"></a>创建用户空间程序栈跟踪数据库（Create user mode stack trace database）</h2><p>使用gflags命令设置，命令格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&#123;EWDK安装目录&#125;\Program Files\Windows Kits\10\Debuggers\x64\gflags&quot; /i ImageName +ust</span><br></pre></td></tr></table></figure></p>
<div class="note "><p>注意：ImageName是指被检测的程序的名称，包含扩展名。例如：glags /i main.exe +ust.</p></div>
<h2 id="设置环境变量-NT-SYMBOL-PATH"><a href="#设置环境变量-NT-SYMBOL-PATH" class="headerlink" title="设置环境变量_NT_SYMBOL_PATH"></a>设置环境变量_NT_SYMBOL_PATH</h2><p>Windows调试工具（WinDbg, KD, CDB, NTST）通过_NT_SYMBOL_PATH查找程序的符号表。在控制台下设置该变量的语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set _NT_SYMBOL_PATH=c:\myapp\symbols;srv*c:\mycache*https://msdl.microsoft.com/download/symbols</span><br></pre></td></tr></table></figure></p>
<div class="note "><ul>
<li>命令中的“c:\myapp\symbols”的路径中包含被检测的文件的pdb文件。</li>
<li>set命令设置环境变量的作用范围是当前的console会话。如需，该环境变量永久有效，请使用setx命令。</li>
</ul></div>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2018/05/14/umdh-memory-leak/#更多" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/13/ubuntu16-libvirt-call-ovsvsctl-denied/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohutou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小虎头 加油">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/13/ubuntu16-libvirt-call-ovsvsctl-denied/" itemprop="url">
                  ubuntu16.04 下libvirtd调用ovs-vsctl被apparmor拒绝
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-13 20:37:28 / 修改时间：20:57:53" itemprop="dateCreated datePublished" datetime="2018-05-13T20:37:28+09:00">2018-05-13</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>项目需求，编译ovs最新的代码。相关的工具，ovs-vsctl、ovs-dpctl等被安装到/usr/local/bin目录下。安装编译完成后，使用virtmanager启动虚拟机失败。查看syslog发现如下的日志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">May  9 18:22:50 liuyao kernel: [ 2450.261787] audit: type=1400 audit(1525861370.039:65): apparmor=&quot;DENIED&quot; operation=&quot;exec&quot; profile=&quot;/usr/sbin/libvirtd&quot; name=&quot;/usr/local/bin/ovs-vsctl&quot; pid=7631 comm=&quot;libvirtd&quot; requested_mask=&quot;x&quot; denied_mask=&quot;x&quot; fsuid=0 ouid=0</span><br><span class="line">May  9 18:22:50 liuyao libvirtd[5499]: internal error: Unable to add port fw2_0 to OVS bridge internal</span><br><span class="line">May  9 18:22:50 liuyao kernel: [ 2450.588343] audit: type=1400 audit(1525861370.367:66): apparmor=&quot;STATUS&quot; operation=&quot;profile_remove&quot; profile=&quot;unconfined&quot; name=&quot;libvirt-fcb1ae08-94a6-4cc0-bf9c-e561f3b8585f&quot; pid=7641 comm=&quot;apparmor_parser&quot;</span><br><span class="line">May  9 18:22:50 liuyao libvirtd[5499]: internal error: Unable to delete port fw2_0 from OVS</span><br></pre></td></tr></table></figure></p>
<p>上面的信息显示，libvirtd在调用ovs-vsctl命令时被apparmor阻止。默认该权限控制文件为/etc/apparmor.d/usr.sbin.libvirtd。在该文件中添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin/* PUx,</span><br></pre></td></tr></table></figure></p>
<p>然后执行下面的命令，虚拟机即可正常启动。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo  apparmor_parser -R /etc/apparmor.d/usr.sbin.libvirtd</span><br><span class="line">sudo apparmor_parser -R /etc/apparmor.d/usr.lib.libvirt.virt-aa-helper</span><br><span class="line">sudo systemctl stop apparmor</span><br><span class="line">sudo systemctl status apparmor</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/01/understanding-lstm-networks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohutou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小虎头 加油">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/01/understanding-lstm-networks/" itemprop="url">
                  深入理解LSTM（Understanding LSTM Networks）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-01 20:26:00" itemprop="dateCreated datePublished" datetime="2018-05-01T20:26:00+09:00">2018-05-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-05-13 21:02:37" itemprop="dateModified" datetime="2018-05-13T21:02:37+09:00">2018-05-13</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" target="_blank" rel="noopener">原文</a>
<h1 id="循环神经网络（Recurrent-Neural-Networks）"><a href="#循环神经网络（Recurrent-Neural-Networks）" class="headerlink" title="循环神经网络（Recurrent Neural Networks）"></a>循环神经网络（Recurrent Neural Networks）</h1><p>思考问题时，人类不是每一时刻都是从零开始的。当你阅读这篇短文时，对于每一个词的理解都是基于这个词之前的词的含义。你不会把前面看到的丢弃，然后从零开始。你的思考是连贯的。</p>
<p>传统的神经网络无法做到这一点，并且这是它的一个主要的缺点。例如，假如你想清楚地知道在一个电影的每一个片段发生了什么样的事情。现在，还不能确定，传统的神经网络如何能够基于已知的事件推断出将要发生的事件。</p>
<p>循环神经网络致力于解决该问题。这样的网络通过环回链接，保持信息的连贯性。</p>

<img src="/2018/05/01/understanding-lstm-networks/RNN-rolled.png" width="100px" height="100px">
<p align="center">带环的循环神经网络 </p>


<p>在上图中，A是一个神经网络的一部分，输入$x_t$得到输出$h_t$。环回链接控制信息被从网络的一层传递到下一层。</p>
<p>这些环回链接使得循环神经网络看起来有些神秘。但是，如果你更进一步地思考，它与普通的神经网络没有太大的区别。一个循环神经网络可以被认为是一个网络的多个拷贝，每一个把信息传递给下一个。对循环神经网络做循环展开后，它就是下面的样子：</p>
<img src="/2018/05/01/understanding-lstm-networks/RNN-unrolled.png">

<p align="center">循环展开的循环神经网络 </p>

<p>这种链式的本质说明了循环神经网络本质上与序列和链表相关。它天生就是要应用到这样的数据上。</p>
<p>当然，它们也是这样被使用的。在过去的几年中，它们在一些领域，取得了难以置信的成功。这个名单很长，主要包括：语音识别、语言模型和图像自动标题等。如果你想深入了解这方面的讨论，请阅读Andrej Karpathy的精彩博文“<a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/" target="_blank" rel="noopener">The Unreasonable Effectiveness of Recurrent Neural Networks.</a>”。这些例子真的是很神奇。</p>
<p>基本上，这些成功的例子都是使用了“LSTMs”。LSTMs是一个特殊的循环神经网络。在很多方面，它都比标准模型做的要好。在循环神经网络的成功案例几乎都是使用它们实现的。本文将主要讨论这些LSTMs模型。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2018/05/01/understanding-lstm-networks/#更多" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/22/ovs-conntrack-tutorial/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohutou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小虎头 加油">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/22/ovs-conntrack-tutorial/" itemprop="url">
                  OpenvSwitch的链接追踪教程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-04-22 01:00:43" itemprop="dateCreated datePublished" datetime="2018-04-22T01:00:43+09:00">2018-04-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-04-27 09:03:17" itemprop="dateModified" datetime="2018-04-27T09:03:17+09:00">2018-04-27</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <a href="http://docs.openvswitch.org/en/latest/tutorials/ovs-conntrack/" target="_blank" rel="noopener">原文 OVS Conntrack Tutorial</a>
<div class="note primary"><p>声明：</p>
<ol>
<li>本译文并未取得原作者授权，如有侵权行为，请发邮件到<a href="mailto:13581561959@163.com" target="_blank" rel="noopener">13581561959@163.com</a>。我将立即删除。</li>
<li>翻译中，意译的地方较多。如有错误，或不准确的地方，欢迎邮件讨论，谢谢。</li>
</ol></div>
<h1 id="OpenvSwitch的链接追踪教程"><a href="#OpenvSwitch的链接追踪教程" class="headerlink" title="OpenvSwitch的链接追踪教程"></a>OpenvSwitch的链接追踪教程</h1><p>OVS能够与链接跟踪系统共同工作，此时Openflow流表被用于捕获TCP、UDP、ICMP等链接各种状态下的报文。（链接跟踪模块支持跟踪有状态和无状态的协议）。<br>本文阐述，如何使用OVS的链路跟踪模块捕获从TCP链接建立到断开的报文。本教程是在Linux平台上完成的，数据报处理模块使用的是Linux内核模块。<br></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2018/04/22/ovs-conntrack-tutorial/#更多" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/17/ovs-on-hyperv-design/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohutou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小虎头 加油">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/17/ovs-on-hyperv-design/" itemprop="url">
                  OVS在Hyper-V平台上的设计原则
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-04-17 22:20:37" itemprop="dateCreated datePublished" datetime="2018-04-17T22:20:37+09:00">2018-04-17</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-04-27 09:01:48" itemprop="dateModified" datetime="2018-04-27T09:01:48+09:00">2018-04-27</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <a href="http://docs.openvswitch.org/en/latest/topics/windows/" target="_blank" rel="noopener">原文 OVS-on-Hyper-V Design</a>
<div class="note primary"><p>声明：</p>
<ol>
<li>本译文并未取得原作者授权，如有侵权行为，请发邮件到<a href="mailto:13581561959@163.com" target="_blank" rel="noopener">13581561959@163.com</a>。我将立即删除。</li>
<li>翻译中，意译的地方较多。如有错误，或不准确的地方，欢迎邮件讨论，谢谢。</li>
</ol></div>
<p>本文将详细说明Open vSwitch是如何在Microsoft的hyper-v平台上开发的。这些信息将帮助您理解整体的设计。<br><blockquote><p>Note：<br>用户空间程序也已经被到了Hyper-V平台上并其提交到了openvswitch的代码库中，这是另一个小组完成的。本文着重阐述内核模块的移植，但是会涉及到用户空间程序。</p>
</blockquote></p>
<h1 id="背景（Background-Info）"><a href="#背景（Background-Info）" class="headerlink" title="背景（Background Info）"></a>背景（Background Info）</h1><p>微软在其虚拟化平台 - Hyper-V 上实现了一个可扩展的虚拟交换机。因此，第三方厂商可以在虚拟交换机上开发新的功能。该扩展是通过将NDIS驱动绑定到可扩展虚拟交换机的驱动栈实现的。可扩展的功能包括监视、修改和转发数据报到Hyper-V交换机的端口。总的来说，可扩展的功能包括以下几种类型：</p>
<ul>
<li>捕获式扩展: 监视数据报</li>
<li>过滤性扩展: 监视、修改数据报</li>
<li>转发式扩展: 监视、修改、转发数据报</li>
</ul>
<p>显而易见，在Hyper-V平台上，OVS的内核模块（datapath）是一个实现了转发功能的NDIS驱动。</p>
<p>在Hyper-V平台上，虚拟机被称为子工作区（Child Partition）。每一个虚拟网络接口或物理网卡通过一个端口（port）连接到虚拟交换机上。上行路径（ingress path）是指数据报从端口被发送出去；下行路径是指数据报在一个端口上被接收。NDIS驱动框架采用了分层接口（a layered interface）的设计模式。在这个分层接口的设计模式中，上行路径中，高层的接口调用其下一层的接口。在下行路径中，则与之相反。另外，控制操作是通过对象标识（OID，object identifier）接口完成的，例如，添加一个端口（port）。这些控制操作的工作流程与数据报的操作一样，高层接口调用底层接口。<a href="https://msdn.microsoft.com/windows/hardware/drivers/network/hyper-v-extensible-switch-components" target="_blank" rel="noopener">Hyper-V Extensible Switch Components</a>中有这方面的详尽的示例图片。</p>
<p>Windows过滤平台（Windows Filtering Platform，WFP）提供了用于过滤数据报的APIs和服务。OVS使用WFP处理一些不能直接处理的数据报。后面将就该问题详细说明。</p>
<p>Hyper-V提供了一组用户获取主机的网络配置信息的接口，被称为IP Helpler。OVS使用这些接口获得必要的网络配置信息。<br></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2018/04/17/ovs-on-hyperv-design/#更多" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/10/lstm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohutou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小虎头 加油">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/10/lstm/" itemprop="url">
                  用于情感分析的LSTM网络(LSTM Networks for Sentiment Analysis)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-04-10 02:56:25" itemprop="dateCreated datePublished" datetime="2018-04-10T02:56:25+09:00">2018-04-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-04-17 22:48:40" itemprop="dateModified" datetime="2018-04-17T22:48:40+09:00">2018-04-17</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <a href="http://deeplearning.net/tutorial/lstm.html" target="_blank" rel="noopener">原文</a>
<blockquote><p>声明：</p>
<ol>
<li>本译文并未取得原作者授权，如有侵权行为，请发邮件到<a href="mailto:13581561959@163.com" target="_blank" rel="noopener">13581561959@163.com</a>。我将立即删除。</li>
<li>翻译中，意译的地方较多。如有错误，或不准确的地方，欢迎邮件讨论，谢谢。</li>
</ol>
</blockquote>
<p>这个教程旨在演示如何使用Theano实现一个基于长短期记忆的循环神经网络。在这里，该模型用于分析最大的影视评论数据集（即IMDB数据集）中的影评中的情感色彩。</p>
<p>在这个教程中，我们将训练一个二分分类的模型。对于给定一个影评，该模型会判断其是积极还是消极的。</p>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>上面已经提到了，本文的python脚本被用于在一个很大的影评数据集上训练长短期记忆循环神经网络模型。</p>
<p>虽然数据是公开的，但是本文作者提供一个已经按照LSTM实现的要求预先处理过的数据集。运行本文提供的代码将自动下载这些数据。如果你想使用自己的数据来训练模型，请使用本文提供的数据预处理脚本对数据进行清洗。</p>
<p>一旦模型被训练完成后，你就能使用你自己的基于本文提供的字典的语料库测试它。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2018/04/10/lstm/#更多" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/04/2018-04-04-21/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohutou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小虎头 加油">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/04/2018-04-04-21/" itemprop="url">
                  华为交换机s57xx端口安全保护导致虚拟机无法联网
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-04-04 22:01:12" itemprop="dateCreated datePublished" datetime="2018-04-04T22:01:12+09:00">2018-04-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-04-07 19:31:02" itemprop="dateModified" datetime="2018-04-07T19:31:02+09:00">2018-04-07</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>某在线的Openstack环境，突发虚拟机不能上网的情况。由于是一个小型的环境，虚拟网络和控制网络并没有分开，整个网络的DHCP由Openstack的DHCP Agent提供。控制网络的操作一切正常。虚拟网络使用Linux系统内置的网桥。</p>
<ol>
<li>在虚拟机的宿主机上使用tcpdump命令能够监测到DHCP消息发出，但是没有DHCP请求的回应消息。</li>
<li>在网络节点DHCP Agent上对应的物理网卡上能检测到虚拟机的DHCP请求和回应消息。</li>
</ol>
<p>基于以上两点，问题应该是交换机没有转发DHCP的回应消息。登陆到交换机后，通过事件命令（system event），发现虚拟网络的接口上有报警事件，显示该端口处于安全保护状态，端口允许的MAC地址的数量的上限为1。至此，问题基本确认。将端口安全保护关掉后，虚拟机能够正常上网。也可以将端口允许的MAC地址数量上限提高，来解决该问题。</p>
<p>在云系统中，将控制网络和存储网络与虚拟网络物理隔离。虚拟网络可以使用功能较少，傻瓜式的两层交换机，能有效避免不必要的网络故障。至于安全方面，Openstack Neutron组件已经做了很好的防护，至于更高级的病毒检测、IPS等则需要通过专门的防火墙完成。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">xiaohutou</p>
              <p class="site-description motion-element" itemprop="description">有志 有识 有恒</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xiaohutou</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.2.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.2.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.2.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.2.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.2.0"></script>



  



	





  





  






<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    






  





  

  

  

  
  

  
  
    
      
    
      
    
      
    
      
    
      
    
      
        
      
    
      
    
      
    
      
    
      
    
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    
  


  
  

  

  

  

  

  

</body>
</html>
